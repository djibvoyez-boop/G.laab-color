<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Plan de travail couleurs</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #f5f5f2;
      --paper: #ffffff;
      --line: #d7d7d0;
      --accent: #ff7a90;
      --accent-soft: rgba(255, 122, 144, 0.15);
      --text: #202020;
      --muted: #8a8a84;
      --border: #c7c7c0;
      --radius-lg: 16px;
      --radius-md: 10px;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text", sans-serif;
      background: repeating-linear-gradient(
        0deg,
        #f5f5f2,
        #f5f5f2 10px,
        #f0f0eb 10px,
        #f0f0eb 20px
      );
      color: var(--text);
      height: 100vh;
      display: flex;
      align-items: stretch;
      justify-content: center;
    }

    .app {
      display: grid;
      grid-template-columns: minmax(270px, 360px) minmax(0, 1fr);
      gap: 18px;
      width: min(1200px, 100vw - 32px);
      margin: 16px auto;
      height: calc(100vh - 32px);
    }

    @media (max-width: 900px) {
      .app {
        grid-template-columns: 1fr;
        grid-template-rows: auto minmax(0, 1fr);
        height: auto;
      }
    }

    .panel {
      background: var(--paper);
      border-radius: var(--radius-lg);
      padding: 16px 16px 12px;
      border: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }

    .panel-title {
      font-size: 16px;
      font-weight: 600;
      letter-spacing: 0.03em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .pill {
      font-size: 11px;
      padding: 4px 9px;
      border-radius: 999px;
      background: var(--accent-soft);
      color: var(--accent);
      border: 1px solid rgba(255, 122, 144, 0.4);
      white-space: nowrap;
    }

    .picker-row {
      display: grid;
      grid-template-columns: 1fr;
      gap: 8px;
      padding: 10px;
      border-radius: var(--radius-md);
      background: #fafaf7;
      border: 1px dashed var(--border);
    }

    .picker-main {
      display: flex;
      align-items: center;
      gap: 14px;
    }

    /* Roue chromatique custom (interactive) */
    .color-wheel-wrap {
      position: relative;
      width: 90px;
      height: 90px;
      border-radius: 50%;
      background:
        conic-gradient(
          #f00,
          #ff0,
          #0f0,
          #0ff,
          #00f,
          #f0f,
          #f00
        );
      cursor: crosshair;
      border: 2px solid #d0d0c8;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .color-wheel-inner {
      position: absolute;
      inset: 18px;
      border-radius: 50%;
      background: var(--paper);
      border: 1px solid #d0d0c8;
    }

    .color-wheel-indicator {
      position: absolute;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      border: 2px solid #ffffff;
      box-sizing: border-box;
      background: #000;
      transform: translate(-50%, -50%);
      pointer-events: none;
    }

    .picker-fields {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .field-label {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
    }

    .hex-row {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .hex-prefix {
      padding: 6px 8px;
      border-radius: 999px;
      background: #f2f2ec;
      border: 1px solid var(--border);
      font-size: 12px;
      color: var(--muted);
    }

    .hex-input {
      flex: 1;
      padding: 6px 8px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: #ffffff;
      color: var(--text);
      font-size: 13px;
      outline: none;
    }

    .hex-input:focus {
      border-color: var(--accent);
    }

    .color-info {
      display: flex;
      flex-direction: column;
      gap: 2px;
      font-size: 11px;
      color: var(--muted);
    }

    .role-buttons {
      display: flex;
      gap: 6px;
      margin-top: 4px;
      flex-wrap: wrap;
    }

    .btn {
      border: 1px solid var(--border);
      border-radius: 999px;
      padding: 6px 9px;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.09em;
      background: #ffffff;
      color: var(--muted);
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      transition: background 0.12s ease, color 0.12s ease, border-color 0.12s ease;
      white-space: nowrap;
    }

    .btn span.dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--muted);
      opacity: 0.7;
    }

    .btn-primary-role {
      border-color: var(--accent);
      color: var(--accent);
      background: #fff5f7;
    }

    .btn:hover {
      border-color: #b0b0aa;
      color: var(--text);
      background: #f9f9f4;
    }

    .btn-primary-role span.dot {
      background: var(--accent);
    }

    .secondary-dot {
      background: #7acbff !important;
    }

    .tertiary-dot {
      background: #c5bf3a !important;
    }

    /* Formes */
    .shape-buttons {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }

    .shape-btn {
      border-radius: 999px;
      border: 1px solid var(--border);
      background: #ffffff;
      padding: 4px 7px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 11px;
      color: var(--muted);
    }

    .shape-btn-icon {
      width: 14px;
      height: 14px;
      border: 1px solid #b8b8b0;
      background: #f7f7f3;
    }

    .shape-btn-icon.rounded {
      border-radius: 4px;
    }

    .shape-btn-icon.circle {
      border-radius: 50%;
    }

    .shape-btn-icon.triangle {
      width: 0;
      height: 0;
      border-left: 7px solid transparent;
      border-right: 7px solid transparent;
      border-bottom: 12px solid #b8b8b0;
      background: transparent;
      border-radius: 0;
    }

    .shape-btn.active {
      border-color: var(--accent);
      background: #fff5f7;
      color: var(--accent);
    }

    /* D√©grad√©s */

    .gradient-block {
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 8px;
      border-radius: var(--radius-md);
      background: #fafaf7;
      border: 1px dashed var(--border);
    }

    .gradient-row {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .gradient-row input {
      flex: 1;
      padding: 6px 8px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: #ffffff;
      font-size: 12px;
    }

    .gradient-row span.arrow {
      font-size: 14px;
      color: var(--muted);
    }

    .gradient-options {
      display: flex;
      gap: 6px;
      margin-top: 4px;
      align-items: center;
      flex-wrap: wrap;
    }

    .gradient-options select {
      padding: 4px 6px;
      border-radius: 999px;
      border: 1px solid var(--border);
      font-size: 11px;
      background: #ffffff;
      color: var(--muted);
    }

    .gradient-options select:focus {
      outline: none;
      border-color: var(--accent);
    }

    .gradient-size-select {
      padding: 4px 6px;
      border-radius: 999px;
      border: 1px solid var(--border);
      font-size: 11px;
      background: #ffffff;
      color: var(--muted);
    }

    .palette-strip {
      display: flex;
      gap: 6px;
      overflow-x: auto;
      padding: 6px 2px 2px;
      scrollbar-width: thin;
      scrollbar-color: #c3c3bc transparent;
    }

    .palette-strip::-webkit-scrollbar {
      height: 6px;
    }
    .palette-strip::-webkit-scrollbar-thumb {
      background: #c3c3bc;
      border-radius: 999px;
    }

    .swatch-chip {
      min-width: 70px;
      max-width: 90px;
      background: #ffffff;
      border-radius: 999px;
      border: 1px solid var(--border);
      padding: 4px 6px;
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 11px;
      color: var(--muted);
      flex-shrink: 0;
    }

    .swatch-chip-color {
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 1px solid rgba(0, 0, 0, 0.15);
    }

    .swatch-chip-text {
      display: flex;
      flex-direction: column;
      gap: 1px;
    }

    .swatch-chip-hex {
      font-size: 11px;
      color: var(--text);
    }

    .swatch-chip-role {
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 0.09em;
    }

    .panel-footer {
      display: flex;
      justify-content: space-between;
      gap: 8px;
      margin-top: 4px;
      flex-wrap: wrap;
    }

    .btn-outline {
      background: transparent;
      border-style: dashed;
      border-color: var(--border);
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.09em;
      color: var(--muted);
      padding: 6px 10px;
      border-radius: 999px;
      cursor: pointer;
    }

    .btn-outline:hover {
      border-color: #b0b0aa;
      color: var(--text);
      background: #f9f9f4;
    }

    .btn-accent {
      background: var(--accent);
      border-color: var(--accent);
      color: #ffffff;
      font-weight: 600;
      padding-inline: 12px;
    }

    .btn-accent:hover {
      filter: brightness(1.05);
    }

    .btn-small {
      font-size: 10px;
      padding: 4px 8px;
    }

    /* Workspace / composition */

    .workspace {
      position: relative;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .workspace-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 4px 2px;
    }

    .workspace-title {
      font-size: 14px;
      font-weight: 600;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .workspace-sub {
      font-size: 11px;
      color: var(--muted);
    }

    .zoom-controls {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 11px;
      color: var(--muted);
    }

    .zoom-btn {
      width: 22px;
      height: 22px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: #ffffff;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 13px;
      padding: 0;
    }

    .zoom-btn:hover {
      background: #f7f7f2;
    }

    .composition {
      position: relative;
      flex: 1;
      min-height: 280px;
      border-radius: var(--radius-lg);
      background: #ffffff;
      border: 1px solid var(--border);
      overflow: hidden;
      padding: 0;
      display: flex;
    }

    .comp-content {
      position: relative;
      width: 100%;
      height: 100%;
      transform-origin: top left;
      background-image:
        linear-gradient(to right, var(--line) 1px, transparent 1px),
        linear-gradient(to bottom, var(--line) 1px, transparent 1px);
      background-size: 40px 40px;
    }

    .color-card {
      position: absolute;
      border-radius: 18px;
      border: 1px solid rgba(0, 0, 0, 0.25);
      cursor: grab;
      user-select: none;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      padding: 8px 10px;
      box-sizing: border-box;
      color: #000;
      background-clip: padding-box;
      /* 2D : PAS d'ombre */
      box-shadow: none;
    }

    .color-card.dragging {
      cursor: grabbing;
    }

    .color-card[data-role="primaire"] {}
    .color-card[data-role="secondaire"] {}
    .color-card[data-role="tertiaire"] {}

    /* Tailles de base par r√¥le */
    .card-lg {
      width: 200px;
      height: 150px;
      font-size: 13px;
    }

    .card-md {
      width: 140px;
      height: 100px;
      font-size: 11px;
    }

    .card-sm {
      width: 90px;
      height: 70px;
      font-size: 10px;
      padding: 6px 8px;
    }

    /* Formes par data-shape */

    .color-card[data-shape="rect"] {
      border-radius: 4px;
    }

    .color-card[data-shape="rounded"] {
      border-radius: 18px;
    }

    .color-card[data-shape="square"] {
      border-radius: 4px;
    }

    .card-lg[data-shape="square"],
    .card-lg[data-shape="circle"],
    .card-lg[data-shape="triangle"] {
      width: 150px;
      height: 150px;
    }

    .card-md[data-shape="square"],
    .card-md[data-shape="circle"],
    .card-md[data-shape="triangle"] {
      width: 110px;
      height: 110px;
    }

    .card-sm[data-shape="square"],
    .card-sm[data-shape="circle"],
    .card-sm[data-shape="triangle"] {
      width: 70px;
      height: 70px;
    }

    .color-card[data-shape="circle"] {
      border-radius: 50%;
      text-align: center;
      align-items: center;
    }

    .color-card[data-shape="triangle"] {
      clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
      align-items: center;
      text-align: center;
      padding: 6px;
    }

    .card-label {
      background: rgba(255, 255, 255, 0.8);
      border-radius: 999px;
      padding: 2px 6px;
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 0.09em;
      align-self: flex-start;
    }

    .card-hex {
      background: rgba(0, 0, 0, 0.45);
      color: #fff;
      border-radius: 999px;
      padding: 3px 7px;
      font-size: 10px;
      max-width: 100%;
    }

    .card-sm .card-label {
      font-size: 8px;
      padding-inline: 5px;
    }

    .card-sm .card-hex {
      font-size: 9px;
      padding: 2px 6px;
    }

    .color-card.selected {
      outline: 2px dashed #333333;
      outline-offset: 2px;
    }

    .empty-hint {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      font-size: 12px;
      color: var(--muted);
      pointer-events: none;
      padding: 0 18px;
    }

    .empty-hint span {
      background: rgba(255, 255, 255, 0.9);
      padding: 8px 12px;
      border-radius: 999px;
      border: 1px solid var(--border);
    }

    .controls-row {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      align-items: center;
      font-size: 11px;
      color: var(--muted);
    }

    .controls-row label {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .controls-row input[type="checkbox"] {
      cursor: pointer;
    }

    .transform-controls {
      display: flex;
      flex-direction: column;
      gap: 4px;
      margin-top: 4px;
      padding-top: 4px;
      border-top: 1px dashed var(--border);
      font-size: 11px;
      color: var(--muted);
    }

    .transform-row {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .transform-row span {
      width: 60px;
    }

    .transform-row input[type="range"] {
      flex: 1;
    }

  </style>
</head>
<body>
  <div class="app">
    <!-- Panneau de gauche : outils -->
    <aside class="panel">
      <div class="panel-header">
        <div class="panel-title">Palette perso</div>
        <div class="pill">Plan de travail 2D ‚úèÔ∏è</div>
      </div>

      <!-- S√©lecteur couleur -->
      <div class="picker-row">
        <div class="picker-main">
          <div class="color-wheel-wrap" id="colorWheel">
            <div class="color-wheel-inner"></div>
            <div class="color-wheel-indicator" id="wheelIndicator"></div>
          </div>

          <div class="picker-fields">
            <div class="field-label">Couleur actuelle</div>
            <div class="hex-row">
              <div class="hex-prefix">HEX</div>
              <input
                id="hexInput"
                class="hex-input"
                value="#ff7a90"
                spellcheck="false"
              />
            </div>
            <div class="color-info">
              <div id="rgbInfo">RGB : 255, 122, 144</div>
              <div id="hslInfo">HSL : 350¬∞, 100%, 74%</div>
            </div>
          </div>
        </div>

        <div class="role-buttons">
          <button class="btn btn-primary-role" data-role="primaire">
            <span class="dot"></span> Primaire
          </button>
          <button class="btn" data-role="secondaire">
            <span class="dot secondary-dot"></span> Secondaire
          </button>
          <button class="btn" data-role="tertiaire">
            <span class="dot tertiary-dot"></span> Tertiaire
          </button>
        </div>
      </div>

      <!-- Forme des cartes -->
      <div>
        <div class="field-label" style="margin-bottom:4px;">Forme des cartes</div>
        <div class="shape-buttons">
          <button class="shape-btn active" data-shape="rounded">
            <div class="shape-btn-icon rounded"></div> Arrondi
          </button>
          <button class="shape-btn" data-shape="rect">
            <div class="shape-btn-icon"></div> Rectangle
          </button>
          <button class="shape-btn" data-shape="square">
            <div class="shape-btn-icon"></div> Carr√©
          </button>
          <button class="shape-btn" data-shape="circle">
            <div class="shape-btn-icon circle"></div> Rond
          </button>
          <button class="shape-btn" data-shape="triangle">
            <div class="shape-btn-icon triangle"></div> Triangle
          </button>
        </div>
      </div>

      <!-- D√©grad√©s -->
      <div class="gradient-block">
        <div class="field-label">Carte d√©grad√©</div>
        <div class="gradient-row">
          <input id="gradStart" placeholder="#ff7a90" value="#ff7a90" />
          <span class="arrow">‚Üí</span>
          <input id="gradEnd" placeholder="#ffffff" value="#ffffff" />
        </div>
        <div class="gradient-options">
          <select id="gradType">
            <option value="linear-h">Lin√©aire horizontal</option>
            <option value="linear-v">Lin√©aire vertical</option>
            <option value="linear-d">Lin√©aire diagonal</option>
            <option value="radial">Radial</option>
          </select>
          <select id="gradSize" class="gradient-size-select">
            <option value="secondaire">Taille secondaire</option>
            <option value="primaire">Taille primaire</option>
            <option value="tertiaire">Taille tertiaire</option>
          </select>
          <button class="btn btn-small" id="addGradientBtn">Ajouter d√©grad√©</button>
        </div>
      </div>

      <div class="field-label">Couleurs ajout√©es</div>
      <div class="palette-strip" id="paletteStrip">
        <!-- Swatches ajout√©s dynamiquement -->
      </div>

      <!-- Contr√¥les texte + suppression -->
      <div class="controls-row">
        <label>
          <input type="checkbox" id="toggleText" checked />
          Afficher le texte sur les cartes
        </label>
        <button class="btn btn-small" id="deleteSelectedBtn">Supprimer s√©lection</button>
      </div>

      <!-- Transformations -->
      <div class="transform-controls">
        <div>Transformations (cartes s√©lectionn√©es) :</div>
        <div class="transform-row">
          <span>Rotation</span>
          <input type="range" id="rotationInput" min="-180" max="180" value="0" disabled />
        </div>
        <div class="transform-row">
          <span>Taille</span>
          <input type="range" id="scaleInput" min="50" max="200" value="100" disabled />
        </div>
        <div style="font-size:10px;">Astuce : clic pour s√©lectionner, Maj+clic pour multi-s√©lection. Touche Suppr = effacer.</div>
      </div>

      <div class="panel-footer">
        <button class="btn-outline" id="resetBtn">Tout effacer</button>
        <button class="btn btn-accent" id="exportBtn">Exporter PNG (fond transparent)</button>
      </div>
    </aside>

    <!-- Panneau de droite : plan de travail -->
    <section class="workspace panel">
      <div class="workspace-header">
        <div>
          <div class="workspace-title">Plan de travail couleurs</div>
          <div class="workspace-sub">
            Glisse, tourne, zoome, superpose tes cartes comme des post-it.
          </div>
        </div>
        <div class="zoom-controls">
          <button class="zoom-btn" id="zoomOutBtn">‚àí</button>
          <span id="zoomLabel">100%</span>
          <button class="zoom-btn" id="zoomInBtn">+</button>
        </div>
      </div>

      <div class="composition" id="composition">
        <div class="comp-content" id="compContent">
          <!-- quadrillage via background -->
        </div>
        <div class="empty-hint" id="emptyHint">
          <span>Ajoute des cartes (couleurs ou d√©grad√©s) puis organise-les ici üìê</span>
        </div>
      </div>
    </section>
  </div>

  <script>
    // --- R√©f√©rences DOM ---
    const hexInput = document.getElementById("hexInput");
    const rgbInfo = document.getElementById("rgbInfo");
    const hslInfo = document.getElementById("hslInfo");
    const roleButtons = document.querySelectorAll(".role-buttons .btn");
    const composition = document.getElementById("composition");
    const compContent = document.getElementById("compContent");
    const emptyHint = document.getElementById("emptyHint");
    const paletteStrip = document.getElementById("paletteStrip");
    const resetBtn = document.getElementById("resetBtn");
    const exportBtn = document.getElementById("exportBtn");
    const toggleTextCheckbox = document.getElementById("toggleText");
    const deleteSelectedBtn = document.getElementById("deleteSelectedBtn");
    const rotationInput = document.getElementById("rotationInput");
    const scaleInput = document.getElementById("scaleInput");
    const zoomOutBtn = document.getElementById("zoomOutBtn");
    const zoomInBtn = document.getElementById("zoomInBtn");
    const zoomLabel = document.getElementById("zoomLabel");
    const shapeButtons = document.querySelectorAll(".shape-btn");
    const colorWheel = document.getElementById("colorWheel");
    const wheelIndicator = document.getElementById("wheelIndicator");

    const gradStartInput = document.getElementById("gradStart");
    const gradEndInput = document.getElementById("gradEnd");
    const gradTypeSelect = document.getElementById("gradType");
    const gradSizeSelect = document.getElementById("gradSize");
    const addGradientBtn = document.getElementById("addGradientBtn");

    let zIndexCounter = 1;
    let showText = true;
    let currentShape = "rounded";
    let currentZoom = 1;
    let wheelDragging = false;
    let currentH = 350;
    let currentS = 100;
    let currentL = 60;

    const selectedCards = new Set();

    // --- Utilitaires couleurs ---
    function normalizeHex(value) {
      if (!value) return null;
      let v = value.trim().toLowerCase();
      if (!v.startsWith("#")) v = "#" + v;
      const shortMatch = /^#([0-9a-f]{3})$/i.exec(v);
      if (shortMatch) {
        const r = shortMatch[1][0];
        const g = shortMatch[1][1];
        const b = shortMatch[1][2];
        v = "#" + r + r + g + g + b + b;
      }
      const hexRegex = /^#([0-9a-f]{6})$/i;
      if (!hexRegex.test(v)) return null;
      return v.toUpperCase();
    }

    function hexToRgb(hex) {
      hex = normalizeHex(hex);
      if (!hex) return null;
      const intVal = parseInt(hex.slice(1), 16);
      const r = (intVal >> 16) & 255;
      const g = (intVal >> 8) & 255;
      const b = intVal & 255;
      return { r, g, b };
    }

    function rgbToHex(r, g, b) {
      return (
        "#" +
        [r, g, b]
          .map((x) => {
            const v = Math.max(0, Math.min(255, Math.round(x)));
            const s = v.toString(16).padStart(2, "0");
            return s;
          })
          .join("")
      ).toUpperCase();
    }

    function rgbToHsl(r, g, b) {
      r /= 255;
      g /= 255;
      b /= 255;
      const max = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      let h, s;
      const l = (max + min) / 2;
      if (max === min) {
        h = s = 0;
      } else {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
          case r:
            h = (g - b) / d + (g < b ? 6 : 0);
            break;
          case g:
            h = (b - r) / d + 2;
            break;
          case b:
            h = (r - g) / d + 4;
            break;
        }
        h /= 6;
      }
      return {
        h: Math.round(h * 360),
        s: Math.round(s * 100),
        l: Math.round(l * 100),
      };
    }

    function hslToHex(h, s, l) {
      h = ((h % 360) + 360) % 360;
      s /= 100;
      l /= 100;
      const c = (1 - Math.abs(2 * l - 1)) * s;
      const x = c * (1 - Math.abs(((h / 60) % 2) - 1));
      const m = l - c / 2;
      let r1, g1, b1;
      if (h < 60) {
        r1 = c; g1 = x; b1 = 0;
      } else if (h < 120) {
        r1 = x; g1 = c; b1 = 0;
      } else if (h < 180) {
        r1 = 0; g1 = c; b1 = x;
      } else if (h < 240) {
        r1 = 0; g1 = x; b1 = c;
      } else if (h < 300) {
        r1 = x; g1 = 0; b1 = c;
      } else {
        r1 = c; g1 = 0; b1 = x;
      }
      const r = (r1 + m) * 255;
      const g = (g1 + m) * 255;
      const b = (b1 + m) * 255;
      return rgbToHex(r, g, b);
    }

    function setCurrentColorFromHex(hex) {
      const validHex = normalizeHex(hex);
      if (!validHex) return;
      hexInput.value = validHex;
      const rgb = hexToRgb(validHex);
      if (rgb) {
        const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
        currentH = hsl.h;
        currentS = hsl.s;
        currentL = hsl.l;
        updateWheelIndicator();
        rgbInfo.textContent = `RGB : ${rgb.r}, ${rgb.g}, ${rgb.b}`;
        hslInfo.textContent = `HSL : ${hsl.h}¬∞, ${hsl.s}%, ${hsl.l}%`;
      }
    }

    function updateWheelIndicator() {
      const wheelRect = colorWheel.getBoundingClientRect();
      const radius = wheelRect.width / 2;
      const innerRadius = radius - 18;
      const angleRad = (currentH - 90) * (Math.PI / 180);
      const cx = radius;
      const cy = radius;
      const x = cx + innerRadius * Math.cos(angleRad);
      const y = cy + innerRadius * Math.sin(angleRad);
      wheelIndicator.style.left = `${x}px`;
      wheelIndicator.style.top = `${y}px`;
      wheelIndicator.style.background = hslToHex(currentH, currentS, currentL);
    }

    function handleWheelEvent(e) {
      const rect = colorWheel.getBoundingClientRect();
      const cx = rect.left + rect.width / 2;
      const cy = rect.top + rect.height / 2;
      const dx = e.clientX - cx;
      const dy = e.clientY - cy;
      const angle = Math.atan2(dy, dx); // -PI..PI
      let deg = (angle * 180) / Math.PI; // -180..180
      deg = deg + 90; // on tourne pour aligner en haut
      if (deg < 0) deg += 360;
      currentH = deg;
      const hex = hslToHex(currentH, currentS, currentL);
      setCurrentColorFromHex(hex);
    }

    // init couleur
    setCurrentColorFromHex("#FF7A90");

    // Roue chromatique interactive
    colorWheel.addEventListener("mousedown", (e) => {
      wheelDragging = true;
      handleWheelEvent(e);
    });
    document.addEventListener("mousemove", (e) => {
      if (wheelDragging) {
        handleWheelEvent(e);
      }
    });
    document.addEventListener("mouseup", () => {
      wheelDragging = false;
    });

    // HEX => mise √† jour
    hexInput.addEventListener("blur", () => {
      const hex = normalizeHex(hexInput.value);
      if (!hex) {
        alert("Code HEX invalide. Exemple : #FF7A90");
        setCurrentColorFromHex(hslToHex(currentH, currentS, currentL));
      } else {
        setCurrentColorFromHex(hex);
      }
    });

    // --- Palette strip ---
    function addSwatch(hex, role, isGradient = false) {
      const swatch = document.createElement("div");
      swatch.classList.add("swatch-chip");

      const colorDot = document.createElement("div");
      colorDot.classList.add("swatch-chip-color");
      if (!isGradient) {
        colorDot.style.background = hex;
      } else {
        colorDot.style.backgroundImage = hex; // hex ici = gradient CSS
      }

      const textWrap = document.createElement("div");
      textWrap.classList.add("swatch-chip-text");

      const hexSpan = document.createElement("div");
      hexSpan.classList.add("swatch-chip-hex");
      hexSpan.textContent = isGradient ? "d√©grad√©" : hex;

      const roleSpan = document.createElement("div");
      roleSpan.classList.add("swatch-chip-role");
      roleSpan.textContent = role;

      textWrap.appendChild(hexSpan);
      textWrap.appendChild(roleSpan);

      swatch.appendChild(colorDot);
      swatch.appendChild(textWrap);

      paletteStrip.appendChild(swatch);
      paletteStrip.scrollTo({ left: paletteStrip.scrollWidth, behavior: "smooth" });
    }

    // --- Forme s√©lectionn√©e ---
    shapeButtons.forEach((btn) => {
      btn.addEventListener("click", () => {
        shapeButtons.forEach((b) => b.classList.remove("active"));
        btn.classList.add("active");
        currentShape = btn.dataset.shape;
      });
    });

    // --- Cr√©ation de carte couleur simple ---
    function createColorCard(hex, role) {
      const card = document.createElement("div");
      card.classList.add("color-card");
      card.classList.add(
        role === "primaire" ? "card-lg" : role === "secondaire" ? "card-md" : "card-sm"
      );
      card.dataset.hex = hex;
      card.dataset.role = role;
      card.dataset.shape = currentShape;
      card.dataset.rotation = "0";
      card.dataset.scale = "1";
      card.style.background = hex;
      card.style.left = "50%";
      card.style.top = "50%";

      const label = document.createElement("div");
      label.classList.add("card-label");
      label.textContent = role;

      const hexLabel = document.createElement("div");
      hexLabel.classList.add("card-hex");
      hexLabel.textContent = hex;

      card.appendChild(label);
      card.appendChild(hexLabel);

      compContent.appendChild(card);
      emptyHint.style.display = "none";

      centerCard(card);
      makeCardInteractive(card);
      applyTextVisibilityToCard(card);

      addSwatch(hex, role);
    }

    // --- Cr√©ation de carte d√©grad√© ---
    function createGradientCard(fromHex, toHex, gradType, role) {
      const card = document.createElement("div");
      card.classList.add("color-card");
      card.classList.add(
        role === "primaire" ? "card-lg" : role === "secondaire" ? "card-md" : "card-sm"
      );

      const start = normalizeHex(fromHex);
      const end = normalizeHex(toHex);
      if (!start || !end) return;

      card.dataset.hex = start;
      card.dataset.role = role;
      card.dataset.shape = currentShape;
      card.dataset.rotation = "0";
      card.dataset.scale = "1";
      card.dataset.gradientFrom = start;
      card.dataset.gradientTo = end;
      card.dataset.gradientType = gradType;

      let cssGradient = "";
      if (gradType === "linear-h") {
        cssGradient = `linear-gradient(90deg, ${start}, ${end})`;
      } else if (gradType === "linear-v") {
        cssGradient = `linear-gradient(180deg, ${start}, ${end})`;
      } else if (gradType === "linear-d") {
        cssGradient = `linear-gradient(135deg, ${start}, ${end})`;
      } else if (gradType === "radial") {
        cssGradient = `radial-gradient(circle, ${start}, ${end})`;
      }
      card.style.background = cssGradient;
      card.style.left = "50%";
      card.style.top = "50%";

      const label = document.createElement("div");
      label.classList.add("card-label");
      label.textContent = "d√©grad√©";

      const hexLabel = document.createElement("div");
      hexLabel.classList.add("card-hex");
      hexLabel.textContent = `${start} ‚Üí ${end}`;

      card.appendChild(label);
      card.appendChild(hexLabel);

      compContent.appendChild(card);
      emptyHint.style.display = "none";

      centerCard(card);
      makeCardInteractive(card);
      applyTextVisibilityToCard(card);

      addSwatch(cssGradient, "d√©grad√©", true);
    }

    // --- Centrage de la carte ---
    function centerCard(card) {
      const compWidth = compContent.clientWidth;
      const compHeight = compContent.clientHeight;
      const cardRect = card.getBoundingClientRect();
      const w = cardRect.width;
      const h = cardRect.height;
      const left = (compWidth - w) / 2;
      const top = (compHeight - h) / 2;
      card.style.left = left + "px";
      card.style.top = top + "px";
    }

    // --- Drag & s√©lection & transform ---
    function makeCardInteractive(card) {
      let isDragging = false;
      let startX = 0;
      let startY = 0;
      let initialLeft = 0;
      let initialTop = 0;
      let moved = false;

      function onMouseDown(e) {
        if (e.button !== 0) return;
        e.preventDefault();
        isDragging = true;
        moved = false;
        card.classList.add("dragging");
        zIndexCounter++;
        card.style.zIndex = zIndexCounter.toString();
        startX = e.clientX;
        startY = e.clientY;
        initialLeft = parseFloat(card.style.left) || 0;
        initialTop = parseFloat(card.style.top) || 0;
        document.addEventListener("mousemove", onMouseMove);
        document.addEventListener("mouseup", onMouseUp);
      }

      function onMouseMove(e) {
        if (!isDragging) return;
        const dx = (e.clientX - startX) / currentZoom;
        const dy = (e.clientY - startY) / currentZoom;
        if (Math.abs(dx) > 2 || Math.abs(dy) > 2) moved = true;

        const compWidth = compContent.clientWidth;
        const compHeight = compContent.clientHeight;
        const cardRect = card.getBoundingClientRect();
        const cardWidth = cardRect.width / currentZoom;
        const cardHeight = cardRect.height / currentZoom;

        let newLeft = initialLeft + dx;
        let newTop = initialTop + dy;

        const margin = 20;
        const maxLeft = compWidth - cardWidth + margin;
        const maxTop = compHeight - cardHeight + margin;
        newLeft = Math.min(Math.max(-margin, newLeft), maxLeft);
        newTop = Math.min(Math.max(-margin, newTop), maxTop);

        card.style.left = newLeft + "px";
        card.style.top = newTop + "px";
      }

      function onMouseUp() {
        isDragging = false;
        card.classList.remove("dragging");
        card.__dragMoved = moved;
        document.removeEventListener("mousemove", onMouseMove);
        document.removeEventListener("mouseup", onMouseUp);
      }

      function onClick(e) {
        // √©viter toggle apr√®s un drag
        if (card.__dragMoved) {
          card.__dragMoved = false;
          return;
        }
        const multi = e.shiftKey || e.metaKey || e.ctrlKey;
        toggleSelection(card, multi);
      }

      card.addEventListener("mousedown", onMouseDown);
      card.addEventListener("click", onClick);

      applyTransformFromDataset(card);
    }

    function toggleSelection(card, multi) {
      if (!multi) {
        if (!card.classList.contains("selected") || selectedCards.size > 1) {
          clearSelection();
        }
      }
      if (card.classList.contains("selected")) {
        card.classList.remove("selected");
        selectedCards.delete(card);
      } else {
        card.classList.add("selected");
        selectedCards.add(card);
      }
      updateTransformControlsFromSelection();
    }

    function clearSelection() {
      selectedCards.forEach((c) => c.classList.remove("selected"));
      selectedCards.clear();
      updateTransformControlsFromSelection();
    }

    function deleteSelected() {
      if (selectedCards.size === 0) return;
      selectedCards.forEach((c) => c.remove());
      selectedCards.clear();
      updateTransformControlsFromSelection();
      if (!compContent.querySelector(".color-card")) {
        emptyHint.style.display = "flex";
      }
    }

    deleteSelectedBtn.addEventListener("click", deleteSelected);
    document.addEventListener("keydown", (e) => {
      if (e.key === "Delete" || e.key === "Backspace") {
        deleteSelected();
      }
    });

    // Cliquer sur le fond = d√©s√©lectionner
    composition.addEventListener("mousedown", (e) => {
      if (e.target === composition || e.target === compContent) {
        clearSelection();
      }
    });

    // Transform sliders
    function applyTransformFromDataset(card) {
      const rot = parseFloat(card.dataset.rotation || "0");
      const scale = parseFloat(card.dataset.scale || "1");
      card.style.transform = `rotate(${rot}deg) scale(${scale})`;
    }

    function updateTransformControlsFromSelection() {
      if (selectedCards.size === 0) {
        rotationInput.disabled = true;
        scaleInput.disabled = true;
        rotationInput.value = 0;
        scaleInput.value = 100;
        return;
      }
      rotationInput.disabled = false;
      scaleInput.disabled = false;
      const first = selectedCards.values().next().value;
      const rot = parseFloat(first.dataset.rotation || "0");
      const scl = parseFloat(first.dataset.scale || "1");
      rotationInput.value = rot;
      scaleInput.value = Math.round(scl * 100);
    }

    rotationInput.addEventListener("input", () => {
      const value = parseFloat(rotationInput.value || "0");
      selectedCards.forEach((card) => {
        card.dataset.rotation = value.toString();
        applyTransformFromDataset(card);
      });
    });

    scaleInput.addEventListener("input", () => {
      const value = parseFloat(scaleInput.value || "100");
      const scl = value / 100;
      selectedCards.forEach((card) => {
        card.dataset.scale = scl.toString();
        applyTransformFromDataset(card);
      });
    });

    // --- Boutons Primaire / Secondaire / Tertiaire ---
    roleButtons.forEach((btn) => {
      btn.addEventListener("click", () => {
        const role = btn.dataset.role;
        const hex = normalizeHex(hexInput.value);
        if (!hex) {
          alert("Entre un code hex valide (ex : #FF7A90).");
          return;
        }
        createColorCard(hex, role);
      });
    });

    // --- Bouton d√©grad√© ---
    addGradientBtn.addEventListener("click", () => {
      const fromHex = gradStartInput.value;
      const toHex = gradEndInput.value;
      const type = gradTypeSelect.value;
      const sizeRole = gradSizeSelect.value; // primaire / secondaire / tertiaire
      const norm1 = normalizeHex(fromHex);
      const norm2 = normalizeHex(toHex);
      if (!norm1 || !norm2) {
        alert("D√©grad√© : entre deux HEX valides (ex : #FF7A90).");
        return;
      }
      createGradientCard(norm1, norm2, type, sizeRole);
    });

    // --- Afficher / masquer texte ---
    function applyTextVisibilityToCard(card) {
      const labels = card.querySelectorAll(".card-label, .card-hex");
      labels.forEach((el) => {
        el.style.display = showText ? "" : "none";
      });
    }

    toggleTextCheckbox.addEventListener("change", () => {
      showText = toggleTextCheckbox.checked;
      const cards = compContent.querySelectorAll(".color-card");
      cards.forEach(applyTextVisibilityToCard);
    });

    // --- Zoom ---
    function updateZoom() {
      compContent.style.transform = `scale(${currentZoom})`;
      zoomLabel.textContent = Math.round(currentZoom * 100) + "%";
    }

    zoomOutBtn.addEventListener("click", () => {
      currentZoom = Math.max(0.5, currentZoom - 0.1);
      updateZoom();
    });

    zoomInBtn.addEventListener("click", () => {
      currentZoom = Math.min(2.5, currentZoom + 0.1);
      updateZoom();
    });

    updateZoom();

    // --- Reset ---
    resetBtn.addEventListener("click", () => {
      const cards = compContent.querySelectorAll(".color-card");
      cards.forEach((c) => c.remove());
      paletteStrip.innerHTML = "";
      emptyHint.style.display = "flex";
      clearSelection();
    });

    // --- Export PNG transparent ---
    exportBtn.addEventListener("click", () => {
      const cards = Array.from(compContent.querySelectorAll(".color-card"));
      if (cards.length === 0) {
        alert("Ajoute au moins une carte avant d'exporter üôÇ");
        return;
      }

      const compWidth = compContent.clientWidth;
      const compHeight = compContent.clientHeight;
      const scale = 2; // qualit√©

      const canvas = document.createElement("canvas");
      canvas.width = compWidth * scale;
      canvas.height = compHeight * scale;
      const ctx = canvas.getContext("2d");

      // fond transparent : on ne remplit rien

      // trier les cartes par z-index
      cards.sort((a, b) => {
        const za = parseInt(a.style.zIndex || "1", 10);
        const zb = parseInt(b.style.zIndex || "1", 10);
        return za - zb;
      });

      function drawCardShape(ctx, shape, x, y, w, h, fillStyle, gradientInfo, rot, scl) {
        // shape: "rect", "rounded", "square", "circle", "triangle"
        ctx.save();

        // on applique la transformation globale (scale du canvas + rotation + scale de la carte)
        ctx.scale(scale, scale);
        ctx.translate(x + w / 2, y + h / 2);
        ctx.rotate((rot * Math.PI) / 180);
        ctx.scale(scl, scl);

        const drawX = -w / 2;
        const drawY = -h / 2;

        let gradient = null;
        if (gradientInfo) {
          const { type, from, to } = gradientInfo;
          if (type === "linear-h") {
            gradient = ctx.createLinearGradient(drawX, drawY, drawX + w, drawY);
          } else if (type === "linear-v") {
            gradient = ctx.createLinearGradient(drawX, drawY, drawX, drawY + h);
          } else if (type === "linear-d") {
            gradient = ctx.createLinearGradient(drawX, drawY, drawX + w, drawY + h);
          } else if (type === "radial") {
            gradient = ctx.createRadialGradient(
              drawX + w / 2, drawY + h / 2, 0,
              drawX + w / 2, drawY + h / 2, Math.max(w, h) / 2
            );
          }
          if (gradient) {
            gradient.addColorStop(0, from);
            gradient.addColorStop(1, to);
          }
        }

        ctx.beginPath();

        if (shape === "circle") {
          const r = Math.min(w, h) / 2;
          ctx.arc(drawX + w / 2, drawY + h / 2, r, 0, Math.PI * 2);
        } else if (shape === "triangle") {
          ctx.moveTo(drawX + w / 2, drawY);
          ctx.lineTo(drawX, drawY + h);
          ctx.lineTo(drawX + w, drawY + h);
          ctx.closePath();
        } else if (shape === "rounded") {
          const radius = 18;
          const r = Math.min(radius, w / 2, h / 2);
          ctx.moveTo(drawX + r, drawY);
          ctx.lineTo(drawX + w - r, drawY);
          ctx.quadraticCurveTo(drawX + w, drawY, drawX + w, drawY + r);
          ctx.lineTo(drawX + w, drawY + h - r);
          ctx.quadraticCurveTo(drawX + w, drawY + h, drawX + w - r, drawY + h);
          ctx.lineTo(drawX + r, drawY + h);
          ctx.quadraticCurveTo(drawX, drawY + h, drawX, drawY + h - r);
          ctx.lineTo(drawX, drawY + r);
          ctx.quadraticCurveTo(drawX, drawY, drawX + r, drawY);
        } else {
          // rect + square
          ctx.rect(drawX, drawY, w, h);
        }

        if (gradient) {
          ctx.fillStyle = gradient;
        } else {
          ctx.fillStyle = fillStyle;
        }
        ctx.fill();

        ctx.restore();
      }

      cards.forEach((card) => {
        const left = parseFloat(card.style.left) || 0;
        const top = parseFloat(card.style.top) || 0;
        const w = card.offsetWidth;
        const h = card.offsetHeight;
        const shape = card.dataset.shape || "rounded";
        const hex = card.dataset.hex || "#FFFFFF";
        const gradientType = card.dataset.gradientType;
        const from = card.dataset.gradientFrom;
        const to = card.dataset.gradientTo;
        const rot = parseFloat(card.dataset.rotation || "0");
        const scl = parseFloat(card.dataset.scale || "1");

        const gradientInfo = gradientType
          ? { type: gradientType, from, to }
          : null;

        drawCardShape(ctx, shape, left, top, w, h, hex, gradientInfo, rot, scl);

        // Texte HEX / r√¥le : seulement si showText actif
        if (showText) {
          ctx.save();
          ctx.scale(scale, scale);
          ctx.translate(left + w / 2, top + h / 2);
          ctx.rotate((rot * Math.PI) / 180);
          ctx.scale(scl, scl);

          const labelY = h / 2 - 12;
          const hexY = -h / 2 + 16;
          ctx.fillStyle = "rgba(255,255,255,0.9)";
          ctx.font = "9px system-ui";
          ctx.textAlign = "center";
          if (gradientInfo) {
            ctx.fillText("d√©grad√©", 0, hexY);
            ctx.fillText(`${from} ‚Üí ${to}`, 0, labelY);
          } else {
            ctx.fillText(hex, 0, labelY);
          }
          ctx.restore();
        }
      });

      const dataUrl = canvas.toDataURL("image/png");
      const link = document.createElement("a");
      link.href = dataUrl;
      link.download = "composition-couleurs.png";
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    });
  </script>
</body>
</html>
